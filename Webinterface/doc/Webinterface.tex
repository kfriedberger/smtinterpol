\documentclass[12pt]{article}
\usepackage{hyperref}
%opening
\title{Documentation for SMTInterpol Webinterface}
\author{Andrea Qosja}
\usepackage[english]{babel}



\begin{document}

\maketitle

\begin{abstract}
This is a short document to describe the experience of using TeaVM to create a Web-Interface in JS for SMTInterpol. It contains a brief explanation of my first try to convert Java into WebAssembly, the concrete usage of TeaVM libraries, and the third part will describe my experience of using TeaVM to convert SMTInterpol including the issues encountered, the solution and the notices for further examination.
\end{abstract}

\section{WebAssembly}

The initial goal of the project was to have our Java code run as WebAssembly code in the browser, since from our search it indicated to have a better performance than JS and to be user friendlier. Three main converter were tested:
\begin{itemize} 
\item[] TeaVm,
\item[] JWebAssembly,
\item[] Bytecoder,
\end{itemize}
all to be found in the this\cite{1} Github-Page.
The three converter did work on ground level(simple examples), but I was unable to test bigger Java-Projects, out of following main reasons.
Inexperience in Java, JavaScript, WebAssembly, Maven and Gradle,
combined with short documentation (maybe written to be understood form experienced user) made it to hard for me to understand the basic principle of all the combined usage of the above mentioned Languages/Tools. I mentioned JavaScript because at the time this document is written, it was not possible to access WebAssembly code in browser without JavaScript. Adding to that WebAssembly is at this time a fairly new, not fully integrated web-programming-language with some missed features, where also different kind of browsers may or may not accept WebAssembly at all, or specific libraries. That is where we decided to bypass WebAssembly and focus on JS only.

\section{TeaVM Usage}

\subsection{First Usage}

The TeaVM usage for converting into JS was good documented and strait forward for our project focus, which was to fetch the input, feed it to SMTInterpol for processing, and give the output back. I had to write a java main file, where the connection with the JS code was done in two parts, which is partially already prepared for you from the TeaVm project build\cite{2}.
Part one, in the html file of the webpage, you should already have this line: $<$body onload="main()"$>$. It starts the connection between your Java main file and the html file, through the classes.js file that was generated by TeaVM containing the translated Java code of your main file.\\
Secondly the connection also works the other way around, meaning from you Java main file, one has access to the elements of the webpage/html document, e.g. the input and the output field. It works through the HTML libraries provided by TeaVM. A short syntax example, to access a html element:  \\
private static HTMLDocument document = Window.current().getDocument(); \\
private static HTMLElement responsePanel = document.getElementById("response-panel"); \\ The "response-panel" is the output panel on the webpage, which you now can modify and rewrite from your Java main file. 

\subsection{Alternative Usage, Web-Worker functionality}

The SMTInterpol can, depending on the input take a certain amount of time, to process, this would freeze the webpage and it was unclear if the program is still processing or not. A solution therefore was the use of web-worker, a JS solution to run the thread on a parallel script. But web-worker is only able to send and receive simple string messages with the main thread, and did not recognise any of the elements of the main thread, therefore the first usage of TeaVM was not compatible with the web-worker's goal. To handle this issue, we reshaped the task for each script and Java file as following, where the usage of TeaVM libraries was also changed.
\subsubsection{First Script}
The first running script is responsible for all the elements of the webpage, for fetching the input, starting the worker script, sending the input to it, waiting for an answer and write it at the webpage when it has the answer.
\subsubsection{Second Script} The second script or the web-worker script will run in the background only when the first script sends the input. It will pause working when it has send back the output and can be completely closed only from the first script.
Here is were the main Java file will load and run at command, so the heavy processing will happen in the background and not effect the webpage. To run our SMTInterpol program we declared a variable runWebInterface, and call runWebInterface.runSMTInterpol(input); when the input is there. Why this works it will be explained in the next sub-section.

\subsubsection{Main Java File}

In contrary to the first usage, we will no longer have access to the elements of the webpage from the main Java file, as we want to load it to the web-worker script, and as explained above, the web-worker script has no access to the elements of the webpage. The syntax therefore simple, you load the main file with importScripts("classes.js");, and initialize it with main();. In this case TeaVM with the right syntax offers usage of the Java classes and single methods from your JavaScript file. As of my knowledge TeaVM uses JSObjects to make this available, and the general explanation of the syntax can be found here\cite{3}. To ensure the functionality we had to make some changes, the first is that the main class now extends an interface named SolverInterface(our choice of name), which itself extends the JSObject interface provided by the TeaVM libraries. In the main class we used the provided syntax to write the next two lines of code: \\
@JSBody(params = { "handler" }, script = "runWebInterface = handler;") \\
public static native void setSolverInterface(SolverInterface handler); \\
The native method setSolverInterface is used just to assign an initialization,  here called handler, of the class SolverInterface to a variable, not to a  Java variable but to a JS one, specifically named runWebInterface, hence the declaration of the variable name in the second script. This means that the Java class Main is initialized as variable in the second script and that we can use all the methods and the functionality of that class in this script. E.g. runWebInterface.runSMTInterpol(input); calls method runSMTInterpol(); from the Main Java class.
Similar coded lines as explained above allowed the use of postMessage-Method of another Java class named WebEnvironment, proving the point that this functionality is not restricted to one single usage.

\section{Experience, Compatibility, Adaptation and Bugs}

\subsection{Possibility for performance enhancer}
There is an option from the compiler of the TeaVM, to be found in the pom.xml file on line 150, that gives the possibility to optimize the code translation from Java to JS, in three increasingly different level SIMPLE, ADVANCED, FULL.

We did not try to test the optimization quotas, and were able to deploy only level SIMPLE, to ensure a stable version.
Since every higher level would result in  errors. Specifically when using higher level of the "Verbosity" option provided by SMTInterpol. To duplicate error just use a higher verbosity value than 1.

\subsection{Supported Java library/classes from TeaVM.}
There is no support/implementation from TeaVM for the Java Formatter Class, and it is not planed to be any in the future\cite{4}. This results in less developer feedback from the Web-Interface regarding the measurement e.g. of the execute speed, since no \%.f numbers can be shown. The only fix possible was commenting the responsible lines out.
Following files contain instances of the described issue: QuantifierTheory.java, ArrayTheory.java, LinArSolve.java.

\subsection{Adaptation}
SMTIntrpol used java.lang.System.exit() as a way to close the program, that was not compatible with JS and needed to be changed, specifically in the parseEnvironment we overwrite the exitWithStatus-Method. \\

The output of SMTInterpol was also very simplified, so that we needed to overwrite just the one function printResponse.\\

TeaVM is also not compatible with unmodifiable sorted set that is why SMTInterpol uses only modifiable one, but only on the TeaVM branch.

\subsection{Bugs}
Issued open at the GitHub page\cite{5} of TeaVM. Simple description: TeaVM implementation of the TreeMap<type, type>.subMap(index, index) is broken, which result in wrongly outcomes and/or errors in the our Web-Interface. \\

HashCode of TeaVM gave an other element as expected, that is why we changed from using Integer.hashCode() to using just HashCode\cite{6}.

\medskip

%Bibliographic references
\begin{thebibliography}{9}
\bibitem{1} 
GitHub page for the three Java to WebAssembly/Js converter. 
\\\textit{\href{https://github.com/appcypher/awesome-wasm-langs\#java}{https://github.com/appcypher/awesome-wasm-langs\#java}}

\bibitem{2} 
Building TeaVM projects. 
\\\textit{\href{http://teavm.org/docs/intro/getting-started.html}{http://teavm.org/docs/intro/getting-started.html}}.

\bibitem{3} 
TeaVM usage of JSObjects.
\\\textit{\href{https://github.com/appcypher/awesome-wasm-langs\#java}{https://github.com/appcypher/awesome-wasm-langs\#java}}

\bibitem{4}
Supported Java Classes from TeaVM.
\\\textit{\href{http://teavm.org/jcl-support/0.6.x/jcl.html}{ http://teavm.org/jcl-support/0.6.x/jcl.html} \\ \href{https://github.com/konsoletyper/teavm/issues/472}{ https://github.com/konsoletyper/teavm/issues/472.}}

\bibitem{5}
SubMap opened issue.
\\\textit{\href{https://github.com/konsoletyper/teavm/issues/519}{https://github.com/konsoletyper/teavm/issues/519}}

\bibitem{6}
Fix for HashCode.
\\\textit{\href{https://github.com/ultimate-pa/smtinterpol/commit/2260635b54c0af738551849c99d2e2a179499da5}{https://github.com/ultimate-pa/smtinterpol/commit/2260635b54c0af738551849c99d2e2a179499da5}}

\end{thebibliography}


\end{document}