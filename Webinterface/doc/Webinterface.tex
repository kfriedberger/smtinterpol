\documentclass[]{article}
\usepackage{hyperref}
%opening
\title{Documentation for SMTInterpol Webinterface}
\author{Andrea Qosja}

\begin{document}

\maketitle

\begin{abstract}
This is a short document to describe the experience of using TeaVM to create a Web-Interface in JS for SMTInterpol. It contains a brief explanation of my first try to convert Java into WebAssembly, the concrete usage of TeaVM libraries, and the third part will describe my experience of using TeaVM to convert SMTInterpol including the issues encountered, the solution and/or the notices for further examination.
\end{abstract}

\section{WebAssembly}

The initial goal of the project was to have our Java code run as WebAssembly code in the browser, since from our search it indicated to have a better performance than JS and to be user friendlier. Three main Converter were tested:
\begin{itemize} 
\item[] TeaVm,
\item[] JWebAssembly,
\item[] Bytecoder,
\end{itemize}
all to be found in the following Github-Page. \\ \href{https://github.com/appcypher/awesome-wasm-langs\#java}{https://github.com/appcypher/awesome-wasm-langs\#java}. \\
The three converter did work on ground level(simple examples), but I was unable to test bigger Java-Projects, out of following main reasons.
Inexperience in Java, JavaScript, WebAssembly, Maven or Gradle,
combined with short documentation (maybe written to be understood form experienced user) made it to hard for me to understand the basic principle of all the combined usage of the above mentioned Languages/Tools. I mentioned JavaScript because at the time this document is written, it was not possible to access WebAssembly code in browser without JavaScript. Adding to that WebAssembly is at this time a fairly new, not fully integrated web-programming-language with some missed features, where also different kind of browsers may or may not accept WebAssembly at all, or specific libraries. That is where we decided to bypass WebAssembly and focus on JS only.

\section{TeaVM Usage}

\subsection{First Usage}

The TeaVM usage for converting into JS was good documented and strait forward for our project focus, which was fetch the input, feed it to SMTInterpol for processing, and give the output back. We had to write a java main file, where the connection with the JS code was done in two parts, which is partially already prepared for you from the build. See following Webpage for how to build a TeaVm project. \\ \href{http://teavm.org/docs/intro/getting-started.html}{http://teavm.org/docs/intro/getting-started.html}. \\
Part one, in the html file of the webpage, you should already have this line: $<$body onload="main()"$>$. It starts the connection between your Java main file and the html file, through the classes.js file that was generated by TeaVM containing the translated Java code of your main file.\\
Second part is that the connection works the other way around, from you Java main file, one has access to the elements of the webpage/html document, like the input and the output field. It works through the HTML libraries provided by TeaVM. A short syntax example, to access a html element:  \\
private static HTMLDocument document = Window.current().getDocument(); \\
private static HTMLElement responsePanel = document.getElementById("response-panel"); \\ The "response-panel" is the output panel on the webpage, which you now can modify and rewrite on you java main file. 

\subsection{Alternative Usage, Web-Worker functionality}

The SMTInterpol can, depending on the input take a certain amount of time, to process, this would freeze the webpage and it was unclear if the program is still processing or not. A solution therefore was the use of web-worker, a JS solution to run the thread on a parallel script. But web-worker is only able to send and receive simple string message with the main thread, and did not recognise any of the elements of the main thread, therefore the first usage of TeaVM was not compatible with the web-worker goal. To handle this issue, we reshaped the task for each script and Java file as following.
\subsubsection{First Script}
The first running script is responsible for all the elements of the webpage, for fetching the input, starting the worker script, sending the input to it, waiting for an answer and write it at the webpage when it has the answer.
\subsubsection{Second Script} The second script or the web-worker script will run in the background only when the first script sends the input. It will pause working when it has send back the output and can be completely  closed from the first script.
Here is were the main java file will be loaded (importing the js translation called classes.js), and calling the function main();, so the heavy processing can happen in the background and not effect the webpage. To run our program the SMTInterpol we declare a variable runWebInterface, and call runWebInterface.runSMTInterpol(input); when the input is there. Why this works it will be explained in the next sub-section.

\subsubsection{Main Java File}



\section{Adaptation, Compatibility, Bugs, Experience}


\subsection{•}  \textbf{Possibility for performance enhancer.} \\
There is an option of the compiler of the TeaVM, to be found in the pom.xml file on line 150. It gives the possibility to optimize the code conversation from Java to JS, in tree increasingly different level SIMPLE, ADVANCED, FULL.

We did not try to test the optimization quotas, and were able to deploy only level SIMPLE, to ensure a stable version.
Since every higher level would result in  errors. Specifically when using higher level of the "Verbosity" option provided from SMTInterpol. To duplicate error just use a higher verbosity value than 1.

\textbf{For future reference:} Here is a possibility to enhance the performance of the interface, \textit{NO} reassurances.   

\begin{itemize}


\item[b)]  \textbf{A bug that should be fixed from TeaVM developers.} \\ Issued open at the Github \href{https://github.com/konsoletyper/teavm/issues/519}{https://github.com/konsoletyper/teavm/issues/519} page of TeaVM. Simple description: TeaVM implementation of the TreeMap<type, type>.subMap(index, index) is broken, which result in wrongly outcomes and/or errors in the our Web-Interface. 

\textbf{For future reference:} It can be possible that the person responsible did not understood the opened issue right, it could bring more to write him again. Although he did not close the issue yet.

\item[c)] \textbf{Supported Java library/classes from TeaVM.} \\ There is no support/implementation from TeaVm for the java Formatter Class, and it is not planed to be any in the future. See\href{http://teavm.org/jcl-support/0.6.x/jcl.html}{ http://teavm.org/jcl-support/0.6.x/jcl.html}, or\href{https://github.com/konsoletyper/teavm/issues/472}{ https://github.com/konsoletyper/teavm/issues/472.} This results in less developer feedback from the Web-Interface regarding the measurement of f.e. execute speed, since no \%.f numbers can be shown. The only fix though was commenting the responsible lines out.
Following files contain instances of the described issue: QuantifierTheory.java, ArrayTheory.java, LinArSolve.java.

\item[d)] Anstatt java lang system.exit(1) java funktion,

parse Env exit funktion, die übergeschirebn, nicht mehr system.exit.

\item[e)] Ausgabe wurde vereifacht, es gibt nur noch eine funktion die man überschreiben muss

\item[f)] unmodifiable sorted set , also nun modifiable, wirt keine Exceptions mehr. ausgenommen nur im TeaVM branch, 

\item[f)] Hashcode, integer hashcode is anderes implementiert als die java.land integer(wert des integer). teaVM.hashcode( gibt ein andere element)

fix: https://github.com/ultimate-pa/smtinterpol/commit/2260635b54c0af738551849c99d2e2a179499da5


\end{itemize}

\end{document}