\documentclass[]{article}
\usepackage{hyperref}
%opening
\title{Documentation for SMTInterpol Webinterface}
\author{Andrea Qosja}
\usepackage[english]{babel}



\begin{document}

\maketitle

\begin{abstract}
This is a short document to describe the experience of using TeaVM to create a Web-Interface in JS for SMTInterpol. It contains a brief explanation of my first try to convert Java into WebAssembly, the concrete usage of TeaVM libraries, and the third part will describe my experience of using TeaVM to convert SMTInterpol including the issues encountered, the solution and/or the notices for further examination.
\end{abstract}

\section{WebAssembly}

The initial goal of the project was to have our Java code run as WebAssembly code in the browser, since from our search it indicated to have a better performance than JS and to be user friendlier. Three main Converter were tested:
\begin{itemize} 
\item[] TeaVm,
\item[] JWebAssembly,
\item[] Bytecoder,
\end{itemize}
all to be found in the this\cite{1} Github-Page.
The three converter did work on ground level(simple examples), but I was unable to test bigger Java-Projects, out of following main reasons.
Inexperience in Java, JavaScript, WebAssembly, Maven or Gradle,
combined with short documentation (maybe written to be understood form experienced user) made it to hard for me to understand the basic principle of all the combined usage of the above mentioned Languages/Tools. I mentioned JavaScript because at the time this document is written, it was not possible to access WebAssembly code in browser without JavaScript. Adding to that WebAssembly is at this time a fairly new, not fully integrated web-programming-language with some missed features, where also different kind of browsers may or may not accept WebAssembly at all, or specific libraries. That is where we decided to bypass WebAssembly and focus on JS only.

\section{TeaVM Usage}

\subsection{First Usage}

The TeaVM usage for converting into JS was good documented and strait forward for our project focus, which was fetch the input, feed it to SMTInterpol for processing, and give the output back. We had to write a java main file, where the connection with the JS code was done in two parts, which is partially already prepared for you from the build. See here\cite{2} for how to build a TeaVm project.
Part one, in the html file of the webpage, you should already have this line: $<$body onload="main()"$>$. It starts the connection between your Java main file and the html file, through the classes.js file that was generated by TeaVM containing the translated Java code of your main file.\\
Second part is that the connection works the other way around, from you Java main file, one has access to the elements of the webpage/html document, like the input and the output field. It works through the HTML libraries provided by TeaVM. A short syntax example, to access a html element:  \\
private static HTMLDocument document = Window.current().getDocument(); \\
private static HTMLElement responsePanel = document.getElementById("response-panel"); \\ The "response-panel" is the output panel on the webpage, which you now can modify and rewrite on you java main file. 

\subsection{Alternative Usage, Web-Worker functionality}

The SMTInterpol can, depending on the input take a certain amount of time, to process, this would freeze the webpage and it was unclear if the program is still processing or not. A solution therefore was the use of web-worker, a JS solution to run the thread on a parallel script. But web-worker is only able to send and receive simple string message with the main thread, and did not recognise any of the elements of the main thread, therefore the first usage of TeaVM was not compatible with the web-worker goal. To handle this issue, we reshaped the task for each script and Java file as following.
\subsubsection{First Script}
The first running script is responsible for all the elements of the webpage, for fetching the input, starting the worker script, sending the input to it, waiting for an answer and write it at the webpage when it has the answer.
\subsubsection{Second Script} The second script or the web-worker script will run in the background only when the first script sends the input. It will pause working when it has send back the output and can be completely closed from the first script.
Here is were the main java file will be loaded (importing the js translation called classes.js), and calling the function main();, so the heavy processing can happen in the background and not effect the webpage. To run our program the SMTInterpol we declare a variable runWebInterface, and call runWebInterface.runSMTInterpol(input); when the input is there. Why this works it will be explained in the next sub-section.

\subsubsection{Main Java File}

In contrary to the first usage, we will no longer have access to the element of the webpage, as we want to load the main file to the web-worker script, and as explained above, neither the web-worker script has access to the elements of the webpage. The syntax is simple, you load the main file with importScripts("classes.js");, and initialize it with main();. In this case TeaVM offers usage of the the classes and/or single methods of java in you JavaScript. As of my knowledge TeaVM uses JSObjects to make this available, and the general explanation of the syntax can be found here\cite{3}. To ensure the functionality we had to make some changes, the first is that the main class now extends an interface named SolverInterface, which itself extends the JSObject interface provided by the TeaVM libraries. In the main class we use the provided syntax to code the next to lines: \\
@JSBody(params = { "handler" }, script = "runWebInterface = handler;") \\
public static native void setSolverInterface(SolverInterface handler); \\
The native method setSolverInterface is used just to assign an initialization,  here called handler, of the class SolverInterface to a variable, not to a  Java variable but to a JS one, specifically named runWebInterface, hence the declaration of the variable name in the second script, this means that the class Main is initialized as variable in the second script and that we can use all the methods and the functionality of the class in that script. We did the same for postMessage-Method.


\section{Experience, Compatibility, Adaptation and Bugs}


\subsection{Possibility for performance enhancer}
There is an option of the compiler of the TeaVM, to be found in the pom.xml file on line 150. It gives the possibility to optimize the code conversation from Java to JS, in tree increasingly different level SIMPLE, ADVANCED, FULL.

We did not try to test the optimization quotas, and were able to deploy only level SIMPLE, to ensure a stable version.
Since every higher level would result in  errors. Specifically when using higher level of the "Verbosity" option provided from SMTInterpol. To duplicate error just use a higher verbosity value than 1.

\subsection{Supported Java library/classes from TeaVM.}
There is no support/implementation from TeaVm for the java Formatter Class, and it is not planed to be any in the future. See here. \cite{4} This results in less developer feedback from the Web-Interface regarding the measurement of f.e. execute speed, since no \%.f numbers can be shown. The only fix though was commenting the responsible lines out.
Following files contain instances of the described issue: QuantifierTheory.java, ArrayTheory.java, LinArSolve.java.

\subsection{Adaptation}
SMTIntrpol used java.lang.System.exit() as a way to close the program, that was not compatible with JS, and needed to be changed, specifically in the parseEnvironment we overwrite the exitWithStatus-Method. \\

The ouput of SMTInterpol was also very simplified, so that we needed to overwrite just the one function printResponse.\\

TeaVM is also not compatible with unmodifiable sorted set that is why SMTInterpol uses only modifiable, but only on the TeaVM branch.

\subsection{Bugs}
Issued open at the GitHub page\cite{5} of TeaVM. Simple description: TeaVM implementation of the TreeMap<type, type>.subMap(index, index) is broken, which result in wrongly outcomes and/or errors in the our Web-Interface. \\

HashCode of TeaVM gave an other Element as expected tha is why we changed from using Integer.hashCode() to using just HashCode. Fic found here. \cite{6}

\medskip

%Bibliographic references
\begin{thebibliography}{9}
\bibitem{1} 
GitHub page for the tr	ee Java to WebAssembly/Js converter. 
\\\textit{\href{https://github.com/appcypher/awesome-wasm-langs\#java}{https://github.com/appcypher/awesome-wasm-langs\#java}}

\bibitem{2} 
Building TeaVM projects. 
\\\textit{\href{http://teavm.org/docs/intro/getting-started.html}{http://teavm.org/docs/intro/getting-started.html}}.

\bibitem{3} 
TeaVM usage of JSObjects.
\\\textit{\href{https://github.com/appcypher/awesome-wasm-langs\#java}{https://github.com/appcypher/awesome-wasm-langs\#java}}

\bibitem{4}
Supported Java Classes from TeaVM.
\\\textit{\href{http://teavm.org/jcl-support/0.6.x/jcl.html}{ http://teavm.org/jcl-support/0.6.x/jcl.html} \\ \href{https://github.com/konsoletyper/teavm/issues/472}{ https://github.com/konsoletyper/teavm/issues/472.}}

\bibitem{5}
SubMap opened issue.
\\\textit{\href{https://github.com/konsoletyper/teavm/issues/519}{https://github.com/konsoletyper/teavm/issues/519}}

\bibitem{6}
Fix for HashCode.
\\\textit{\href{https://github.com/ultimate-pa/smtinterpol/commit/2260635b54c0af738551849c99d2e2a179499da5}{https://github.com/ultimate-pa/smtinterpol/commit/2260635b54c0af738551849c99d2e2a179499da5}}

\end{thebibliography}


\end{document}